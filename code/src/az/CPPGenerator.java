package az;

import java.io.BufferedReader;
import java.io.File;
import java.io.StringReader;
import java.util.ArrayList;
import java.util.Hashtable;
import java.util.Set;
import java.util.TreeSet;
import java.util.logging.Logger;
import java.util.logging.Level;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;

import org.w3c.dom.Comment;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

public class CPPGenerator extends AbstractGenerator
{
    private static final Logger log = Logger.getLogger(CPPGenerator.class.getName());
    static String TEMPLATE_H = "h.template";
    static String TEMPLATE_CPP = "cpp.template";
    static String TEMPLATE_DERIVED_H = "h.derived.template";
    static String TEMPLATE_DERIVED_CPP = "cpp.derived.template";

    public CPPGenerator(Hashtable<String, Integer> globalEventIndex,
      Hashtable<String, Integer> engineEventIndex)
    {
      super(globalEventIndex, engineEventIndex);
    }

    public StringBuffer genFile(BufferedReader templateReader,
            boolean makeVirtual)
    {
        StringBuffer output = new StringBuffer();
        boolean notFirstLine = false;

        try
        {
            while (templateReader.ready())
            {
                String s = templateReader.readLine();

                if(s == null)
                {
                    break;
                }

                if(notFirstLine)
                {
                  output.append("\n");
                }
                else
                {
                  notFirstLine = true;
                }

                Pattern p = Pattern.compile(".*(\\$\\{(.*)\\}).*");
                Matcher m = p.matcher(s);
                boolean b = m.matches();
                if (b)
                {
                    String key = m.group(2);
                    String matchedString = Pattern.quote(m.group(1));

                    if (key.equals("CLASS_NAME"))
                    {
                        String result = s.replaceAll(matchedString, CLASS_NAME);
                        output.append(result);
                        
                    }
                    else if (key.equals("PREAMBLE_START"))
                    {
                        output.append(s + "\n");
                        output.append("// Autogenerated from " + inputFile + " using AZEngine.\n");

                        while (templateReader.ready())
                        {
                            String tempString = templateReader.readLine();
                            Matcher matches = p.matcher(tempString);
                            boolean didMatch = matches.matches();
                            if (didMatch)
                            {
                                String newKey = matches.group(2);

                                if (newKey.equals("PREAMBLE_END"))
                                {
                                    output.append(tempString);
                                    break;
                                }
                            }
                        }
                    }
                    else if (key.equals("STATE_INDEXES_START"))
                    {
                        Set<String> stateNames = stateIndex.keySet();
                        TreeSet<String> orderedSet = new TreeSet<String>(
                                stateNames);
                        output.append(s + "\n");
                        for (String stateName : orderedSet)
                        {
                            output.append("  static const int " + stateName + " = "
                                    + stateIndex.get(stateName) + ";\n");
                        }

                        while (templateReader.ready())
                        {
                            String tempString = templateReader.readLine();
                            Matcher matches = p.matcher(tempString);
                            boolean didMatch = matches.matches();
                            if (didMatch)
                            {
                                String newKey = matches.group(2);

                                if (newKey.equals("STATE_INDEXES_END"))
                                {
                                    output.append(tempString);
                                    break;
                                }
                            }
                        }
                    }
                    else if (key.equals("INPUT_INDEXES_START"))
                    {
                        output.append(s + "\n");
/*
                        Set<String> eventNames = localEventIndex.keySet();
                        TreeSet<String> orderedEventSet = new TreeSet<String>(
                                eventNames);

                        for (String eventName : orderedEventSet)
                        {
                            if(engineEventIndex.get(eventName) == null)
                            {
                                output.append("  static const int " + eventName + " = "
                                    + localEventIndex.get(eventName) + ";\n");
                            }
                        }
*/
                        while (templateReader.ready())
                        {
                            String tempString = templateReader.readLine();
                            Matcher matches = p.matcher(tempString);
                            boolean didMatch = matches.matches();
                            if (didMatch)
                            {
                                String newKey = matches.group(2);

                                if (newKey.equals("INPUT_INDEXES_END"))
                                {
                                    output.append(tempString);
                                    break;
                                }
                            }
                        }
                    }
                    else if (key.equals("TRANSITION_METHODS_DECLARATIONS_START"))
                    {
                        output.append(s + "\n");
                        for (Transition transition : transitions)
                        {
                            if (makeVirtual)
                            {
                                output.append("  virtual void "
                                        + STATE_METHOD_PREFIX 
                                        + transition.startStateId + "_ON_" 
                                        + transition.eventId + "();\n");
                            }
                            else
                            {
                                output.append("  void "
                                        + STATE_METHOD_PREFIX 
                                        + transition.startStateId + "_ON_" 
                                        + transition.eventId + "();\n");
                            }
                        }

                        while (templateReader.ready())
                        {
                            String tempString = templateReader.readLine();
                            Matcher matches = p.matcher(tempString);
                            boolean didMatch = matches.matches();
                            if (didMatch)
                            {
                                String newKey = matches.group(2);

                                if (newKey.equals("TRANSITION_METHODS_DECLARATIONS_END"))
                                {
                                    output.append(tempString);
                                    break;
                                }
                            }
                        }
                    }
                    else if (key.equals("TRANSITION_METHODS_DEFINITIONS"))
                    {
                        for (Transition transition : transitions)
                        {
                            output.append("void " + CLASS_NAME + "::"
                                   + STATE_METHOD_PREFIX 
                                   + transition.startStateId + "_ON_" 
                                   + transition.eventId + "() {}\n");
                        }
                    }
                    else if (key.equals("STATE_METHODS_DECLARATIONS_START"))
                    {
                        Set<String> stateNames = stateIndex.keySet();
                        TreeSet<String> orderedSet = new TreeSet<String>(
                                stateNames);

                        output.append(s + "\n");
                        for (String stateName : orderedSet)
                        {
                            if (makeVirtual)
                            {
                                output.append("  virtual void "
                                        + STATE_METHOD_PREFIX + stateName
                                        + "();\n");
                            }
                            else
                            {
                                output.append("  void " + STATE_METHOD_PREFIX
                                        + stateName + "();\n");
                            }
                        }

                        while (templateReader.ready())
                        {
                            String tempString = templateReader.readLine();
                            Matcher matches = p.matcher(tempString);
                            boolean didMatch = matches.matches();
                            if (didMatch)
                            {
                                String newKey = matches.group(2);

                                if (newKey.equals("STATE_METHODS_DECLARATIONS_END"))
                                {
                                    output.append(tempString);
                                    break;
                                }
                            }
                        }
                    }
                    else if (key.equals("STATE_METHODS_DEFINITIONS"))
                    {
                        Set<String> stateNames = stateIndex.keySet();
                        TreeSet<String> orderedSet = new TreeSet<String>(
                                stateNames);

                        for (String stateName : orderedSet)
                        {
                            output.append("void " + CLASS_NAME + "::"
                                    + STATE_METHOD_PREFIX + stateName + "()");
                            String code = codeBlocks.get(stateName);
                            if (code != null)
                            {
                                output.append("{\n");
                                output.append(code + "\n");
                                output.append("}\n\n");
                            }
                            else
                            {
                                output.append(" {}\n");
                            }
                        }
                    }
                    else if (key.equals("TABLE_INSERTIONS_START"))
                    {
                        output.append(s + "\n");

                        output.append("  transition_info_t info;\n");
                        for (Transition transition : transitions)
                        {
                            output.append("  info.transitionMethod = (MethodIndex)&" + CLASS_NAME + "::"
                                   + STATE_METHOD_PREFIX 
                                   + transition.startStateId + "_ON_" 
                                   + transition.eventId + ";\n");

                            output.append("  info.stateMethod = (MethodIndex)&" + CLASS_NAME + "::"
                                   + STATE_METHOD_PREFIX 
                                   + transition.endStateId + ";\n");

                            output.append("  info.stateIndex = "
                                   + transition.endStateId + ";\n");

                            output.append("  stateMachine.InsertTransition(0, "
                                   + transition.startStateId + ", "
                                   + transition.eventId + ", info);\n\n");
                        }

                        while (templateReader.ready())
                        {
                            String tempString = templateReader.readLine();
                            Matcher matches = p.matcher(tempString);
                            boolean didMatch = matches.matches();
                            if (didMatch)
                            {
                                String newKey = matches.group(2);

                                if (newKey.equals("TABLE_INSERTIONS_END"))
                                {
                                    output.append(tempString);
                                    break;
                                }
                            }
                        }
                    }
                    else if (key.equals("STATE_METHOD_POINTERS_START"))
                    {
                        Set<String> stateNames = stateIndex.keySet();
                        TreeSet<String> orderedSet = new TreeSet<String>(
                                stateNames);

                        output.append(s + "\n");
                        output.append("  mi = new MethodIndex["
                                + (orderedSet.size() + 1) + "];\n");
                        String[] name = orderedSet.toArray(new String[2]);
                        for (int i = 0; i < orderedSet.size(); i++)
                        {
                            output.append("  mi[" + name[i] + "] = (MethodIndex)&"
                                    + CLASS_NAME + "::AZ_" + name[i] + ";\n");
                        }

                        while (templateReader.ready())
                        {
                            String tempString = templateReader.readLine();
                            Matcher matches = p.matcher(tempString);
                            boolean didMatch = matches.matches();
                            if (didMatch)
                            {
                                String newKey = matches.group(2);

                                if (newKey.equals("STATE_METHOD_POINTERS_END"))
                                {
                                    output.append(tempString);
                                    break;
                                }
                            }
                        }
                    }
                    else if (key.equals("INITIAL_STATE_START"))
                    {
                        output.append(s + "\n");
                        output.append("  info.transitionMethod = 0;\n");
                        output.append("  info.stateMethod = (MethodIndex)&" + CLASS_NAME + "::"
                               + STATE_METHOD_PREFIX 
                               + initialState + ";\n");

                        output.append("  info.stateIndex = " + initialState + ";\n");

                        output.append("  m_CurrentInfo = info;\n");
                        output.append("  m_PreviousInfo = info;\n");
                        output.append("  SetInitialInfo(info);\n");

                        while (templateReader.ready())
                        {
                            String tempString = templateReader.readLine();
                            Matcher matches = p.matcher(tempString);
                            boolean didMatch = matches.matches();
                            if (didMatch)
                            {
                                String newKey = matches.group(2);

                                if (newKey.equals("INITIAL_STATE_END"))
                                {
                                    output.append(tempString);
                                    break;
                                }
                            }
                        }
                    }
                    else if (key.equals("POPULATE_DEBUG_INPUT_INDEX_START"))
                    {
                        Set<String> eventNames = localEventIndex.keySet();
                        TreeSet<String> orderedEventSet = new TreeSet<String>(
                                eventNames);

                        output.append(s + "\n");

                        for (String eventName : orderedEventSet)
                        {
//                            output.append("  m_DebugInputIndex[" + eventName + "] = \"" + eventName + "\";\n");
                        }

                        while (templateReader.ready())
                        {
                            String tempString = templateReader.readLine();
                            Matcher matches = p.matcher(tempString);
                            boolean didMatch = matches.matches();
                            if (didMatch)
                            {
                                String newKey = matches.group(2);

                                if (newKey.equals("POPULATE_DEBUG_INPUT_INDEX_END"))
                                {
                                    output.append(tempString);
                                    break;
                                }
                            }
                        }
                    }
                    else if (key.equals("SET_DIAGRAM_NAME_ON_DEBUGGER_START"))
                    {
                        output.append(s + "\n");
                        output.append("  m_StateDebugger.SetDiagramName(GetTemplateName());\n");
  
                        while (templateReader.ready())
                        {
                            String tempString = templateReader.readLine();
                            Matcher matches = p.matcher(tempString);
                            boolean didMatch = matches.matches();
                            if (didMatch)
                            {
                                String newKey = matches.group(2);

                                if (newKey.equals("SET_DIAGRAM_NAME_ON_DEBUGGER_END"))
                                {
                                    output.append(tempString);
                                    break;
                                }
                            }
                        }
                    }
                    else if (key.equals("DEBUG_ACCESSORS_START"))
                    {
                        output.append(s + "\n");
                        output.append("  inline std::string GetStateAsText(int StateIndex)\n");
                        output.append("  {\n");
                        output.append("      return m_DebugStateIndex[StateIndex];\n");
                        output.append("  }\n");
                        output.append("  \n");

                        output.append("  inline std::string GetInputAsText(int InputIndex)\n");
                        output.append("  {\n");
                        output.append("      return az::debugInputIndex[InputIndex];\n");
                        output.append("  }\n");
                        output.append("  \n");

                        output.append("  inline std::string GetTemplateName()\n");
                        output.append("  {\n");
                        File f = new File(inputFile);
                        output.append("      return std::string(\"" + f.getName() + "\");\n");
                        output.append("  }\n");

                        while (templateReader.ready())
                        {
                            String tempString = templateReader.readLine();
                            Matcher matches = p.matcher(tempString);
                            boolean didMatch = matches.matches();
                            if (didMatch)
                            {
                                String newKey = matches.group(2);

                                if (newKey.equals("DEBUG_ACCESSORS_END"))
                                {
                                    output.append(tempString);
                                    break;
                                }
                            }
                        }
                    }
                    else if (key.equals("POPULATE_DEBUG_STATE_INDEX_START"))
                    {
                        Set<String> stateNames = stateIndex.keySet();
                        output.append(s + "\n");

                        for (String stateName : stateNames)
                        {
                            output.append("  m_DebugStateIndex[" + stateName + "] = \"" + stateName + "\";\n");
                        }

                        while (templateReader.ready())
                        {
                            String tempString = templateReader.readLine();
                            Matcher matches = p.matcher(tempString);
                            boolean didMatch = matches.matches();
                            if (didMatch)
                            {
                                String newKey = matches.group(2);

                                if (newKey.equals("POPULATE_DEBUG_STATE_INDEX_END"))
                                {
                                    output.append(tempString);
                                    break;
                                }
                            }
                        }
                    }
                    else if (key.equals("DEBUG_INPUT_INDEXES_START"))
                    {
                        Set<String> eventNames = localEventIndex.keySet();
                        output.append(s + "\n");
                        output.append("  std::string m_DebugInputIndex[" + eventNames.size() + "];\n");

                        while (templateReader.ready())
                        {
                            String tempString = templateReader.readLine();
                            Matcher matches = p.matcher(tempString);
                            boolean didMatch = matches.matches();
                            if (didMatch)
                            {
                                String newKey = matches.group(2);

                                if (newKey.equals("DEBUG_INPUT_INDEXES_END"))
                                {
                                    output.append(tempString);
                                    break;
                                }
                            }
                        }
                    }
                    else if (key.equals("DEBUG_STATE_INDEXES_START"))
                    {
                        Set<String> stateNames = stateIndex.keySet();
                        output.append(s + "\n");
                        output.append("  std::string m_DebugStateIndex[" + (stateNames.size() + 1) + "];\n");

                        while (templateReader.ready())
                        {
                            String tempString = templateReader.readLine();
                            Matcher matches = p.matcher(tempString);
                            boolean didMatch = matches.matches();
                            if (didMatch)
                            {
                                String newKey = matches.group(2);

                                if (newKey.equals("DEBUG_STATE_INDEXES_END"))
                                {
                                    output.append(tempString);
                                    break;
                                }
                            }
                        }
                    }
                }
                else
                {
                    output.append(s);
                }
            }
            return output;
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }

        return null;
    }

    public String generateDefault(String template, String className)
    {
        return generate(template, className, makeVirtual);
    }

    public String generateCPP(String className, boolean makeVirtual, boolean derived)
    {
        if(derived)
        {
          return generate(TEMPLATE_DERIVED_CPP, className, makeVirtual);
        }
        else
        {
          return generate(TEMPLATE_CPP, className, makeVirtual);
        }
    }

    public String generateDefaultCPP(String className)
    {
        return generateDefault(TEMPLATE_CPP, className);
    }

    public String generateH(String className, boolean makeVirtual, boolean derived)
    {
        if(derived)
        {
          return generate(TEMPLATE_DERIVED_H, className, makeVirtual);
        }
        else
        {
          return generate(TEMPLATE_H, className, makeVirtual);
        }
    }

    public String generateDefaultH(String className)
    {
        return generateDefault(TEMPLATE_H, className);
    }
    
    public void generateFiles(String className, String outputPath, boolean makeVirtual, boolean derived)
    {
        String fileBaseName = outputPath;
        if(fileBaseName == null)
        {
            fileBaseName = "";
        }
        if(!fileBaseName.equals("") && !fileBaseName.endsWith(File.separator))
        {
            fileBaseName += File.separator;
        }
        String outputFile = fileBaseName + className + ".cpp";
        log.log(Level.INFO, "Attempting to generated: " + outputFile);
        String cppCode = null;
        File f = new File(outputFile);
        if (f.exists() && !f.isDirectory())
        {
          log.log(Level.INFO, "Output file already exists. Using it as the template.");
          cppCode = generateFromExisting(outputFile, className, makeVirtual);
        }
        else
        {
          log.log(Level.INFO, "Output file does not exist. Creating new from template.");
          cppCode = generateCPP(className, makeVirtual, derived);
        }
        writeToFile(cppCode, outputFile);
        outputFile = fileBaseName + className + ".h";
        log.log(Level.INFO, "Attempting to generated: " + outputFile);
        String hCode = null;
        f = new File(outputFile);
        if (f.exists() && !f.isDirectory())
        {
          log.log(Level.INFO, "Output file already exists. Using it as the template.");
          hCode = generateFromExisting(outputFile, className, makeVirtual);
        }
        else
        {
          log.log(Level.INFO, "Output file does not exist. Creating new from template.");
          hCode = generateH(className, makeVirtual, derived);
        }
        writeToFile(hCode, outputFile);
    }

    public void generateDefaultCPPFiles(String className, String outputPath)
    {
        String cppCode = generateDefaultCPP(className);
        writeToFile(cppCode, className + ".cpp");
        String hCode = generateDefaultH(className);
        writeToFile(hCode, className + ".h");
    }
}
