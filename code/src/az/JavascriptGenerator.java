package az;

import java.io.BufferedReader;
import java.io.File;
import java.io.StringReader;
import java.util.ArrayList;
import java.util.Hashtable;
import java.util.Set;
import java.util.TreeSet;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;

import org.w3c.dom.Comment;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

public class JavascriptGenerator extends AbstractGenerator
{
    static String TEMPLATE_JS = "js.template";

    public StringBuffer genFile(BufferedReader templateReader,
            boolean makeVirtual)
    {
        StringBuffer output = new StringBuffer();

        try
        {
            while (templateReader.ready())
            {
                String s = templateReader.readLine();

                if(s == null)
                {
                    break;
                }

                Pattern p = Pattern.compile(".*(\\$\\{(.*)\\}).*");
                Matcher m = p.matcher(s);
                boolean b = m.matches();
                if (b)
                {
                    String key = m.group(2);
                    String matchedString = Pattern.quote(m.group(1));

                    if (key.equals("CLASS_NAME"))
                    {
                        String result = s.replaceAll(matchedString, CLASS_NAME);
                        output.append(result);
                        
                    }
                    else if (key.equals("PREAMBLE_START"))
                    {
                        output.append(s + "\n");
                        output.append("// Autogenerated from " + inputFile + " using AZEngine.\n");

                        while (templateReader.ready())
                        {
                            String tempString = templateReader.readLine();
                            Matcher matches = p.matcher(tempString);
                            boolean didMatch = matches.matches();
                            if (didMatch)
                            {
                                String newKey = matches.group(2);

                                if (newKey.equals("PREAMBLE_END"))
                                {
                                    output.append(tempString);
                                    break;
                                }
                            }
                        }
                    }
                    else if (key.equals("STATE_INDEXES_START"))
                    {
                        Set<String> stateNames = stateIndex.keySet();
                        TreeSet<String> orderedSet = new TreeSet<String>(
                                stateNames);
                        output.append(s + "\n");
                        for (String stateName : orderedSet)
                        {
                            output.append("    this." + stateName + " = "
                                    + stateIndex.get(stateName) + ";\n");
                        }

                        while (templateReader.ready())
                        {
                            String tempString = templateReader.readLine();
                            Matcher matches = p.matcher(tempString);
                            boolean didMatch = matches.matches();
                            if (didMatch)
                            {
                                String newKey = matches.group(2);

                                if (newKey.equals("STATE_INDEXES_END"))
                                {
                                    output.append(tempString);
                                    break;
                                }
                            }
                        }
                    }
                    else if (key.equals("INPUT_INDEXES_START"))
                    {
                        Set<String> eventNames = eventIndex.keySet();
                        TreeSet<String> orderedEventSet = new TreeSet<String>(
                                eventNames);

                        output.append(s + "\n");
                        for (String eventName : orderedEventSet)
                        {
                            output.append("    this." + eventName + " = "
                                    + eventIndex.get(eventName) + ";\n");
                        }

                        while (templateReader.ready())
                        {
                            String tempString = templateReader.readLine();
                            Matcher matches = p.matcher(tempString);
                            boolean didMatch = matches.matches();
                            if (didMatch)
                            {
                                String newKey = matches.group(2);

                                if (newKey.equals("INPUT_INDEXES_END"))
                                {
                                    output.append(tempString);
                                    break;
                                }
                            }
                        }
                    }
                    else if (key.equals("TRANSITION_METHODS_DECLARATIONS_START"))
                    {
                        output.append(s + "\n");
                        for (Transition transition : transitions)
                        {
                            if (makeVirtual)
                            {
                                output.append("  virtual void "
                                        + STATE_METHOD_PREFIX 
                                        + transition.startStateId + "_ON_" 
                                        + transition.eventId + "();\n");
                            }
                            else
                            {
                                output.append("  void "
                                        + STATE_METHOD_PREFIX 
                                        + transition.startStateId + "_ON_" 
                                        + transition.eventId + "();\n");
                            }
                        }

                        while (templateReader.ready())
                        {
                            String tempString = templateReader.readLine();
                            Matcher matches = p.matcher(tempString);
                            boolean didMatch = matches.matches();
                            if (didMatch)
                            {
                                String newKey = matches.group(2);

                                if (newKey.equals("TRANSITION_METHODS_DECLARATIONS_END"))
                                {
                                    output.append(tempString);
                                    break;
                                }
                            }
                        }
                    }
                    else if (key.equals("TRANSITION_METHODS_DEFINITIONS"))
                    {
                        for (Transition transition : transitions)
                        {
                            output.append("  " + STATE_METHOD_PREFIX 
                                   + transition.startStateId + "_ON_" 
                                   + transition.eventId + "() {}\n");
                        }
                    }
                    else if (key.equals("STATE_METHODS_DECLARATIONS_START"))
                    {
                        Set<String> stateNames = stateIndex.keySet();
                        TreeSet<String> orderedSet = new TreeSet<String>(
                                stateNames);

                        output.append(s + "\n");
                        for (String stateName : orderedSet)
                        {
                            if (makeVirtual)
                            {
                                output.append("  virtual void "
                                        + STATE_METHOD_PREFIX + stateName
                                        + "();\n");
                            }
                            else
                            {
                                output.append("  void " + STATE_METHOD_PREFIX
                                        + stateName + "();\n");
                            }
                        }

                        while (templateReader.ready())
                        {
                            String tempString = templateReader.readLine();
                            Matcher matches = p.matcher(tempString);
                            boolean didMatch = matches.matches();
                            if (didMatch)
                            {
                                String newKey = matches.group(2);

                                if (newKey.equals("STATE_METHODS_DECLARATIONS_END"))
                                {
                                    output.append(tempString);
                                    break;
                                }
                            }
                        }
                    }
                    else if (key.equals("STATE_METHODS_DEFINITIONS"))
                    {
                        Set<String> stateNames = stateIndex.keySet();
                        TreeSet<String> orderedSet = new TreeSet<String>(
                                stateNames);

                        for (String stateName : orderedSet)
                        {
                            output.append("  " + STATE_METHOD_PREFIX + stateName + "()");
                            String code = codeBlocks.get(stateName);
                            if (code != null)
                            {
                                output.append("{\n");
                                output.append(code + "\n");
                                output.append("}\n\n");
                            }
                            else
                            {
                                output.append(" {}\n");
                            }
                        }
                    }
                    else if (key.equals("TABLE_INSERTIONS_START"))
                    {
                        output.append(s + "\n");

                        for (Transition transition : transitions)
                        {
                            output.append("    {\n");
                            output.append("      var info = new TransitionInfo();\n");
                            output.append("      info.transitionMethod = this." + STATE_METHOD_PREFIX 
                                   + transition.startStateId + "_ON_" 
                                   + transition.eventId + ";\n");

                            output.append("      info.stateMethod = this." + STATE_METHOD_PREFIX 
                                   + transition.endStateId + ";\n");

                            output.append("      info.stateIndex = this."
                                   + transition.endStateId + ";\n");

                            output.append("      this.stateMachine.insertTransition(0, this."
                                   + transition.startStateId + ", this."
                                   + transition.eventId + ", info);\n");
                            output.append("    }\n");
                        }

                        while (templateReader.ready())
                        {
                            String tempString = templateReader.readLine();
                            Matcher matches = p.matcher(tempString);
                            boolean didMatch = matches.matches();
                            if (didMatch)
                            {
                                String newKey = matches.group(2);

                                if (newKey.equals("TABLE_INSERTIONS_END"))
                                {
                                    output.append(tempString);
                                    break;
                                }
                            }
                        }
                    }
                    else if (key.equals("STATE_METHOD_POINTERS_START"))
                    {
                        Set<String> stateNames = stateIndex.keySet();
                        TreeSet<String> orderedSet = new TreeSet<String>(
                                stateNames);

                        output.append(s + "\n");
                        output.append("  mi = new MethodIndex["
                                + (orderedSet.size() + 1) + "];\n");
                        String[] name = orderedSet.toArray(new String[2]);
                        for (int i = 0; i < orderedSet.size(); i++)
                        {
                            output.append("  mi[" + name[i] + "] = (MethodIndex)&"
                                    + CLASS_NAME + "::AZ_" + name[i] + ";\n");
                        }

                        while (templateReader.ready())
                        {
                            String tempString = templateReader.readLine();
                            Matcher matches = p.matcher(tempString);
                            boolean didMatch = matches.matches();
                            if (didMatch)
                            {
                                String newKey = matches.group(2);

                                if (newKey.equals("STATE_METHOD_POINTERS_END"))
                                {
                                    output.append(tempString);
                                    break;
                                }
                            }
                        }
                    }
                    else if (key.equals("INITIAL_STATE_START"))
                    {
                        output.append(s + "\n");
                        output.append("    {\n");
                        output.append("      var info = new TransitionInfo();\n");
                        output.append("      info.transitionMethod = undefined;\n");
                        output.append("      info.stateMethod = this."
                               + STATE_METHOD_PREFIX 
                               + initialState + ";\n");

                        output.append("      info.stateIndex = this." + initialState + ";\n");

                        output.append("      this.currentInfo = info;\n");
                        output.append("      this.previousInfo = info;\n");
                        output.append("      this.setInitialStateInfo(info);\n");
                        output.append("    }\n");

                        while (templateReader.ready())
                        {
                            String tempString = templateReader.readLine();
                            Matcher matches = p.matcher(tempString);
                            boolean didMatch = matches.matches();
                            if (didMatch)
                            {
                                String newKey = matches.group(2);

                                if (newKey.equals("INITIAL_STATE_END"))
                                {
                                    output.append(tempString);
                                    break;
                                }
                            }
                        }
                    }
                    else if (key.equals("POPULATE_DEBUG_INPUT_INDEX_START"))
                    {
                        Set<String> eventNames = eventIndex.keySet();
                        TreeSet<String> orderedEventSet = new TreeSet<String>(
                                eventNames);

                        output.append(s + "\n");

                        for (String eventName : orderedEventSet)
                        {
                            output.append("  m_DebugInputIndex[" + eventName + "] = \"" + eventName + "\";\n");
                        }

                        while (templateReader.ready())
                        {
                            String tempString = templateReader.readLine();
                            Matcher matches = p.matcher(tempString);
                            boolean didMatch = matches.matches();
                            if (didMatch)
                            {
                                String newKey = matches.group(2);

                                if (newKey.equals("POPULATE_DEBUG_INPUT_INDEX_END"))
                                {
                                    output.append(tempString);
                                    break;
                                }
                            }
                        }
                    }
                    else if (key.equals("SET_DIAGRAM_NAME_ON_DEBUGGER_START"))
                    {
                        output.append(s + "\n");
                        output.append("  m_StateDebugger.SetDiagramName(GetTemplateName());\n");
  
                        while (templateReader.ready())
                        {
                            String tempString = templateReader.readLine();
                            Matcher matches = p.matcher(tempString);
                            boolean didMatch = matches.matches();
                            if (didMatch)
                            {
                                String newKey = matches.group(2);

                                if (newKey.equals("SET_DIAGRAM_NAME_ON_DEBUGGER_END"))
                                {
                                    output.append(tempString);
                                    break;
                                }
                            }
                        }
                    }
                    else if (key.equals("DEBUG_ACCESSORS_START"))
                    {
                        output.append(s + "\n");
                        output.append("  inline std::string GetStateAsText(int StateIndex)\n");
                        output.append("  {\n");
                        output.append("      return m_DebugStateIndex[StateIndex];\n");
                        output.append("  }\n");
                        output.append("  \n");

                        output.append("  inline std::string GetInputAsText(int InputIndex)\n");
                        output.append("  {\n");
                        output.append("      return m_DebugInputIndex[InputIndex];\n");
                        output.append("  }\n");
                        output.append("  \n");

                        output.append("  inline std::string GetTemplateName()\n");
                        output.append("  {\n");
                        File f = new File(inputFile);
                        output.append("      return std::string(\"" + f.getName() + "\");\n");
                        output.append("  }\n");

                        while (templateReader.ready())
                        {
                            String tempString = templateReader.readLine();
                            Matcher matches = p.matcher(tempString);
                            boolean didMatch = matches.matches();
                            if (didMatch)
                            {
                                String newKey = matches.group(2);

                                if (newKey.equals("DEBUG_ACCESSORS_END"))
                                {
                                    output.append(tempString);
                                    break;
                                }
                            }
                        }
                    }

                    else if (key.equals("POPULATE_DEBUG_STATE_INDEX_START"))
                    {
                        Set<String> stateNames = stateIndex.keySet();
                        output.append(s + "\n");

                        for (String stateName : stateNames)
                        {
                            output.append("  m_DebugStateIndex[" + stateName + "] = \"" + stateName + "\";\n");
                        }

                        while (templateReader.ready())
                        {
                            String tempString = templateReader.readLine();
                            Matcher matches = p.matcher(tempString);
                            boolean didMatch = matches.matches();
                            if (didMatch)
                            {
                                String newKey = matches.group(2);

                                if (newKey.equals("POPULATE_DEBUG_STATE_INDEX_END"))
                                {
                                    output.append(tempString);
                                    break;
                                }
                            }
                        }
                    }
                    else if (key.equals("DEBUG_INPUT_INDEXES_START"))
                    {
                        Set<String> eventNames = eventIndex.keySet();
                        output.append(s + "\n");
                        output.append("  std::string m_DebugInputIndex[" + eventNames.size() + "];\n");

                        while (templateReader.ready())
                        {
                            String tempString = templateReader.readLine();
                            Matcher matches = p.matcher(tempString);
                            boolean didMatch = matches.matches();
                            if (didMatch)
                            {
                                String newKey = matches.group(2);

                                if (newKey.equals("DEBUG_INPUT_INDEXES_END"))
                                {
                                    output.append(tempString);
                                    break;
                                }
                            }
                        }
                    }
                    else if (key.equals("DEBUG_STATE_INDEXES_START"))
                    {
                        Set<String> stateNames = stateIndex.keySet();
                        output.append(s + "\n");
                        output.append("  std::string m_DebugStateIndex[" + (stateNames.size() + 1) + "];\n");

                        while (templateReader.ready())
                        {
                            String tempString = templateReader.readLine();
                            Matcher matches = p.matcher(tempString);
                            boolean didMatch = matches.matches();
                            if (didMatch)
                            {
                                String newKey = matches.group(2);

                                if (newKey.equals("DEBUG_STATE_INDEXES_END"))
                                {
                                    output.append(tempString);
                                    break;
                                }
                            }
                        }
                    }
                }
                else
                {
                    output.append(s);
                }

                output.append("\n");
            }
            return output;
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }

        return null;
    }

    public void generateFiles(String className, String outputPath, boolean makeVirtual, boolean derived)
    {
        String fileBaseName = outputPath;
        if(fileBaseName == null)
        {
            fileBaseName = "";
        }
        if(!fileBaseName.equals("") && !fileBaseName.endsWith(File.separator))
        {
            fileBaseName += File.separator;
        }
        String code = generateJavascript(className, makeVirtual, derived);
        writeToFile(code, fileBaseName + className + ".js");
    }

    public String generateJavascript(String className, boolean makeVirtual, boolean derived)
    {
        if(derived)
        {
          return generate(TEMPLATE_JS, className, makeVirtual);
        }
        else
        {
          return generate(TEMPLATE_JS, className, makeVirtual);
        }
    }
}
